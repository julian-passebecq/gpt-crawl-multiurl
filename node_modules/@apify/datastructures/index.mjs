"use strict";
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/linked_list.ts
var dataEqual = /* @__PURE__ */ __name((data1, data2) => {
  if (data1 === null)
    return data2 === null;
  if (data1.equals)
    return data1.equals(data2);
  return data1 === data2;
}, "dataEqual");
var LinkedListNode = class {
  constructor(data) {
    this.data = data;
    this.prev = null;
    this.next = null;
  }
};
__name(LinkedListNode, "LinkedListNode");
var LinkedList = class {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }
  add(data, toFirstPosition) {
    const node = new LinkedListNode(data);
    this.addNode(node, toFirstPosition);
    return node;
  }
  addNode(node, toFirstPosition) {
    if (typeof node !== "object" || node === null)
      throw new Error('Parameter "node" must be an object');
    if (node.prev || node.next)
      throw new Error("New node is still included in some linked list");
    node.prev = null;
    node.next = null;
    if (this.length === 0) {
      this.tail = node;
      this.head = node;
    } else if (toFirstPosition) {
      node.next = this.head;
      this.head.prev = node;
      this.head = node;
    } else {
      node.prev = this.tail;
      this.tail.next = node;
      this.tail = node;
    }
    this.length++;
  }
  find(data) {
    for (let node = this.head; node != null; node = node.next) {
      if (dataEqual(node.data, data)) {
        return node;
      }
    }
    return null;
  }
  removeNode(node) {
    if (typeof node !== "object" || node == null)
      throw new Error('Parameter "node" must be an object');
    if (node.prev != null) {
      if (node.next != null) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        node.prev = null;
        node.next = null;
      } else {
        this.tail = node.prev;
        node.prev.next = null;
        node.prev = null;
      }
    } else if (node.next != null) {
      this.head = node.next;
      node.next.prev = null;
      node.next = null;
    } else {
      this.head = null;
      this.tail = null;
      node.next = null;
      node.prev = null;
    }
    this.length--;
  }
  removeFirst() {
    const { head } = this;
    if (!head)
      return null;
    this.removeNode(head);
    return head.data;
  }
};
__name(LinkedList, "LinkedList");

// src/list_dictionary.ts
var ListDictionary = class {
  constructor() {
    this.linkedList = new LinkedList();
    this.dictionary = {};
  }
  length() {
    return this.linkedList.length;
  }
  add(key, item, toFirstPosition) {
    if (typeof key !== "string")
      throw new Error('Parameter "key" must be a string.');
    if (key in this.dictionary)
      return false;
    const linkedListNode = this.linkedList.add(item, toFirstPosition);
    linkedListNode.dictKey = key;
    this.dictionary[key] = linkedListNode;
    return true;
  }
  getFirst() {
    const { head } = this.linkedList;
    if (head)
      return head.data;
    return null;
  }
  getLast() {
    const { tail } = this.linkedList;
    if (tail)
      return tail.data;
    return null;
  }
  moveFirstToEnd() {
    const node = this.linkedList.head;
    if (!node)
      return null;
    this.linkedList.removeNode(node);
    this.linkedList.addNode(node);
    return node.data;
  }
  removeFirst() {
    const { head } = this.linkedList;
    if (!head)
      return null;
    this.linkedList.removeNode(head);
    delete this.dictionary[head.dictKey];
    return head.data;
  }
  removeLast() {
    const { tail } = this.linkedList;
    if (!tail)
      return null;
    this.linkedList.removeNode(tail);
    delete this.dictionary[tail.dictKey];
    return tail.data;
  }
  remove(key) {
    if (typeof key !== "string")
      throw new Error('Parameter "key" must be a string.');
    const node = this.dictionary[key];
    if (!node)
      return null;
    delete this.dictionary[key];
    this.linkedList.removeNode(node);
    return node.data;
  }
  get(key) {
    if (typeof key !== "string")
      throw new Error('Parameter "key" must be a string.');
    const node = this.dictionary[key];
    if (!node)
      return null;
    return node.data;
  }
  clear() {
    if (this.linkedList.length > 0) {
      this.linkedList = new LinkedList();
      this.dictionary = {};
    }
  }
};
__name(ListDictionary, "ListDictionary");

// src/lru_cache.ts
var LruCache = class {
  constructor(options) {
    this.options = options;
    this.listDictionary = new ListDictionary();
    this.maxLength = this.options.maxLength;
    if (typeof options.maxLength !== "number") {
      throw new Error('Parameter "maxLength" must be a number.');
    }
  }
  length() {
    return this.listDictionary.length();
  }
  get(key) {
    if (typeof key !== "string")
      throw new Error('Parameter "key" must be a string.');
    const node = this.listDictionary.dictionary[key];
    if (!node)
      return null;
    this.listDictionary.remove(key);
    this.listDictionary.add(key, node.data);
    return node.data;
  }
  add(key, value) {
    const added = this.listDictionary.add(key, value);
    if (!added)
      return false;
    if (this.length() > this.maxLength) {
      this.listDictionary.removeFirst();
    }
    return true;
  }
  remove(key) {
    return this.listDictionary.remove(key);
  }
  clear() {
    return this.listDictionary.clear();
  }
};
__name(LruCache, "LruCache");
export {
  LinkedList,
  LinkedListNode,
  ListDictionary,
  LruCache
};
/*!
 * This module defines the LinkedList class, which represents a doubly-linked list data structure.
 *
 * Author: Jan Curn (jan@apify.com)
 * Copyright(c) 2014 Apify. All rights reserved.
 *
 */
/*!
 * This module defines the ListDictionary class, a data structure
 * that combines a linked list and a dictionary.
 *
 * Author: Jan Curn (jan@apify.com)
 * Copyright(c) 2015 Apify. All rights reserved.
 *
 */
//# sourceMappingURL=index.mjs.map