import { JsonVariable } from './utilities.client';
declare class WebhookPayloadTemplateError extends Error {
    constructor(message?: string);
}
export declare class InvalidJsonError extends WebhookPayloadTemplateError {
    constructor(originalError: Error);
}
export declare class InvalidVariableError extends Error {
    constructor(variable?: string);
}
/**
 * WebhookPayloadTemplate enables creation and parsing of webhook payload template strings.
 * Template strings are JSON that may include template variables enclosed in double
 * curly brackets: `{{variable}}`. When the template is parsed, variables are replaced
 * with values from a provided context.
 *
 * This is useful to create dynamic webhook payloads where a template is saved on webhook
 * creation and then variables are dynamically added on webhook dispatch.
 *
 * **Example:**
 * ```js
 * const payloadTemplate = `{
 *    "id": "some-id",
 *    "createdAt": "2019-05-08T15:22:21.095Z",
 *    "dataToSend": {{data}}
 * }`
 *
 * const data = {
 *     status: 200,
 *     body: 'hello world'
 * }
 *
 * const payloadObject = WebhookPayloadTemplate.parse(payloadTemplate, null, { data })
 * ```
 *
 * **Produces:**
 * ```js
 * {
 *     id: "some-id",
 *    createdAt: '2019-05-08T15:22:21.095Z',
 *    dataToSend: {
 *        status: 200,
 *        body: 'hello world'
 *    }
 * }
 * ```
 * @hideconstructor
 */
export declare class WebhookPayloadTemplate {
    private readonly template;
    private readonly allowedVariables;
    private readonly context;
    private payload;
    readonly replacedVariables: {
        variableName: string;
        replacement: string;
    }[];
    constructor(template: string, allowedVariables?: Set<string> | null, context?: Record<string, any>);
    /**
     * Parse existing webhook payload template string into an object, replacing
     * template variables using the provided context.
     *
     * Parse also validates the template structure, so it can be used
     * to check validity of the template JSON and usage of allowedVariables.
     */
    static parse(payloadTemplate: string, allowedVariables?: Set<string> | null, context?: Record<string, any>, options?: {
        interpolateStrings?: boolean;
    }): Record<string, any>;
    /**
     * Stringify an object into a webhook payload template.
     * Values created using `getTemplateVariable('foo.bar')`
     * will be stringified to `{{foo.bar}}` template variable.
     */
    static stringify(objectTemplate: Record<string, any>, replacer?: ((_: any) => string) | null, indent?: number): string;
    /**
     * Produces an instance of a template variable that can be used
     * in objects and will be stringified into `{{variableName}}` syntax.
     *
     * **Example:**
     * ```js
     * const resourceVariable = WebhookPayloadTemplate.getVariable('resource');
     * const objectTemplate = {
     *     foo: 'foo',
     *     bar: ['bar'],
     *     res: resourceVariable,
     * }
     *
     * const payloadTemplate = WebhookPayloadTemplate.stringify(objectTemplate);
     * ```
     *
     * **Produces:**
     * ```json
     * {
     *     "foo": "foo",
     *     "bar": ["bar"],
     *     "res": {{resource}},
     * }
     * ```
     */
    static getVariable(variableName: string): JsonVariable;
    private _parse;
    private _interpolate;
    private _interpolateString;
    private _interpolateObject;
    private _interpolateArray;
    private _findPositionOfNextVariable;
    private _isVariableInsideString;
    private _countUnescapedDoubleQuotesUpToIndex;
    private _replaceVariable;
    private _validateVariableName;
    private _getVariableValue;
    private _getVariableReplacement;
}
export {};
