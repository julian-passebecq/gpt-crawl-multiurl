/*!
 * This module contains various server utility and helper functions.
 * Note that it automatically exports functions from utilities.client.js
 *
 * Author: Jan Curn (jan@apify.com)
 * Copyright(c) 2015 Apify. All rights reserved.
 *
 */
import { Log } from '@apify/log';
/**
 * Generates a random cryptographically strong string consisting of 17 alphanumeric characters.
 * This string is similar to MongoDB ObjectIds generated by Meteor.
 */
export declare function cryptoRandomObjectId(length?: number): string;
/**
 * Generates unique, deterministic record ID from the provided key with given length (defaults to 17).
 */
export declare function deterministicUniqueId(key: string, length?: number): string;
/**
 * Returns a random integer between 0 and max (excluded, unless it is also 0).
 * @param {number} maxExcluded
 * @returns {number}
 */
export declare function getRandomInt(maxExcluded: number): number;
/**
 * If 'date' is a String, this function converts and returns it as a Date object.
 * Otherwise, the function returns the original 'date' argument.
 * This function is useful to convert dates transfered via JSON which doesn't natively support dates.
 */
export declare function parseDateFromJson(date: string | Date): Date;
/**
 * Returns a Promise object that will wait a specific number of milliseconds.
 * @param {number} millis Time to wait. If the value is not larger than zero, the promise resolves immediately.
 */
export declare function delayPromise(millis: number): Promise<void>;
/**
 * Removes an element from an array.
 */
export declare function removeFromArray<T>(array: T[], element: T): boolean;
interface RequestLike {
    url: string;
}
interface ResponseLike {
    status: (code: number) => void;
    send: (payload: string) => void;
    headersSent?: boolean;
}
/**
 * A default route for HTTP 404 error page for API endpoints.
 */
export declare function http404Route(req: RequestLike, res: ResponseLike): void;
/**
 * Default error handler of Express API endpoints.
 */
export declare function expressErrorHandler(err: Error, req: RequestLike, res: ResponseLike, next: (...a: unknown[]) => unknown): unknown;
export type BetterIntervalID = {
    _betterClearInterval: () => void;
};
/**
 * Similar to setInterval() but with two important differences:
 * First, it assumes the function is asynchronous and only schedules its next invocation AFTER the asynchronous function finished.
 * Second, it invokes the function immediately.
 * @param func Asynchronous function to be periodically executed. It must take a single argument with a callback that
 * the function must invoke after it's done.
 * @param delay The number of milliseconds to wait to next invocation of the function.
 * @returns Object that can be passed to betterClearInterval()
 */
export declare function betterSetInterval(func: (a: (...args: unknown[]) => unknown) => void, delay: number): BetterIntervalID;
export declare function betterClearInterval(intervalID: BetterIntervalID): void;
/**
 * Escapes a string so that it can be used in regular expression (e.g. converts "myfile.*" to "myfile\\.\\*").
 */
export declare function escapeRegExp(str: string): string;
/**
 * String left pad
 */
export declare function leftpad(str: string, len: number, ch?: string | number): string;
/**
 * Computes weighted average of 2 values.
 */
export declare function weightedAverage(val1: number, weight1: number, val2: number, weight2: number): number;
/**
 * Checks whether username is listed in FORBIDDEN_USERNAMES
 * or matches any root route path.
 */
export declare function isForbiddenUsername(username: string): boolean;
/**
 * Executes array of promises in sequence and then returns array where Nth item is result of Nth promise.
 */
export declare function sequentializePromises<T>(promises: (Promise<T> | (() => Promise<T>))[]): Promise<T[]>;
/**
 * Helper function for validation if parameter is an instance of given prototype or multiple prototypes.
 */
export declare function checkParamPrototypeOrThrow(paramVal: any, paramName: string, prototypes: any, prototypeName: string, isOptional?: boolean): void;
interface Server {
    removeListener(event: string, cb: (...params: any[]) => any): unknown;
    on(event: string, cb: (...params: any[]) => any): unknown;
    listen(port: number): unknown;
}
/**
 * Starts listening at a port specified in the constructor.
 * Unfortunately server.listen() is not a normal function that fails on error, so we need this trickery.
 * Returns a function that calls `server.listen(port)` and resolves once server starts listening.
 *
 * Usage: `promisifyServerListen(server)(1234)`;
 */
export declare function promisifyServerListen<T extends Server>(server: T): (port: number) => Promise<void>;
export declare function configureLogger(givenLog: Log, isProduction?: boolean): void;
/**
 * Wraps given promise with timeout.
 */
export declare function timeoutPromise<T>(promise: Promise<T>, timeoutMillis: number, errorMessage?: string): Promise<unknown>;
export {};
